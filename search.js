const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require("discord.js")
const musicManager = require("../utils/musicManager")
const ytSearch = require("yt-search")

console.log("üéµ [MUSIC] Cargando comando search...")

module.exports = {
  name: "search",
  description: "Busca canciones en YouTube",
  cooldown: 5,

  data: new SlashCommandBuilder()
    .setName("search")
    .setDescription("Busca canciones en YouTube")
    .addStringOption((option) =>
      option.setName("query").setDescription("T√©rmino de b√∫squeda").setRequired(true)
    ),

  async execute(interactionOrMessage, args) {
    const isInteraction = !!interactionOrMessage.isChatInputCommand
    const context = interactionOrMessage

    console.log(`üéµ [MUSIC] ===== COMANDO SEARCH EJECUTADO =====`)
    console.log(`üéµ [MUSIC] Usuario: ${context.user?.tag || context.author?.tag}`)
    console.log(`üéµ [MUSIC] Servidor: ${context.guild.name}`)
    console.log(`üéµ [MUSIC] Tipo: ${isInteraction ? 'Slash Command' : 'Mensaje'}`)

    const reply = async (options) => {
      if (isInteraction) {
        if (context.deferred || context.replied) {
          return context.editReply(options)
        }
        return context.reply(options)
      }
      return context.reply(options)
    }

    try {
      const query = isInteraction ? context.options.getString("query") : args.join(" ")
      
      if (!query || query.trim().length === 0) {
        console.log(`‚ùå [MUSIC] Query de b√∫squeda vac√≠a`)
        const embed = new EmbedBuilder()
          .setColor("#ff0000")
          .setTitle("‚ùå Query Vac√≠a")
          .setDescription("¬°Debes especificar un t√©rmino de b√∫squeda!")
          .setTimestamp()

        return await reply({ embeds: [embed], ephemeral: isInteraction })
      }

      console.log(`üîç [MUSIC] Buscando: ${query}`)

      if (isInteraction) {
        await context.deferReply()
        console.log(`üéµ [MUSIC] Respuesta diferida, procesando b√∫squeda...`)
      }

      // Realizar b√∫squeda en YouTube
      const searchResults = await ytSearch(query)
      
      if (!searchResults.videos || searchResults.videos.length === 0) {
        console.log(`‚ùå [MUSIC] No se encontraron resultados para: ${query}`)
        const embed = new EmbedBuilder()
          .setColor("#ff9900")
          .setTitle("üîç B√∫squeda Sin Resultados")
          .setDescription(`No se encontraron resultados para **${query}**`)
          .addFields({
            name: "üí° Consejos",
            value: "‚Ä¢ Intenta con t√©rminos m√°s espec√≠ficos\n‚Ä¢ Verifica la ortograf√≠a\n‚Ä¢ Usa palabras clave diferentes",
            inline: false
          })
          .setTimestamp()

        if (isInteraction) {
          await context.editReply({ embeds: [embed] })
        } else {
          await context.reply({ embeds: [embed] })
        }
        return
      }

      // Limitar a 10 resultados
      const videos = searchResults.videos.slice(0, 10)
      console.log(`‚úÖ [MUSIC] Encontrados ${videos.length} resultados`)

      // Crear embed de resultados
      const embed = new EmbedBuilder()
        .setColor("#00ff00")
        .setTitle("üîç Resultados de B√∫squeda")
        .setDescription(`Resultados para **${query}**`)
        .setTimestamp()

      // A√±adir campos para cada video
      videos.forEach((video, index) => {
        const duration = video.duration ? musicManager.formatDuration(video.duration.seconds) : "Desconocida"
        const title = video.title.length > 50 ? video.title.substring(0, 47) + "..." : video.title
        
        embed.addFields({
          name: `${index + 1}. ${title}`,
          value: `üë§ ${video.author.name} ‚Ä¢ ‚è±Ô∏è ${duration} ‚Ä¢ üì∫ [Ver en YouTube](${video.url})`,
          inline: false
        })
      })

      // Crear botones para selecci√≥n
      const rows = []
      for (let i = 0; i < Math.ceil(videos.length / 5); i++) {
        const row = new ActionRowBuilder()
        const startIndex = i * 5
        const endIndex = Math.min(startIndex + 5, videos.length)
        
        for (let j = startIndex; j < endIndex; j++) {
          const button = new ButtonBuilder()
            .setCustomId(`search_${context.user?.id || context.author?.id}_${j}`)
            .setLabel(`${j + 1}`)
            .setStyle(ButtonStyle.Primary)
          
          row.addComponents(button)
        }
        
        rows.push(row)
      }

      // A√±adir bot√≥n de cancelar
      const cancelRow = new ActionRowBuilder()
        .addComponents(
          new ButtonBuilder()
            .setCustomId(`search_cancel_${context.user?.id || context.author?.id}`)
            .setLabel("‚ùå Cancelar")
            .setStyle(ButtonStyle.Danger)
        )
      rows.push(cancelRow)

      // Enviar resultados
      if (isInteraction) {
        await context.editReply({ 
          embeds: [embed], 
          components: rows 
        })
      } else {
        await context.reply({ 
          embeds: [embed], 
          components: rows 
        })
      }

      console.log(`üéµ [MUSIC] ===== COMANDO SEARCH COMPLETADO EXITOSAMENTE =====`)

      // Configurar timeout para limpiar botones
      setTimeout(() => {
        try {
          const disabledRows = rows.map(row => {
            const newRow = ActionRowBuilder.from(row)
            newRow.components.forEach(component => {
              if (component instanceof ButtonBuilder) {
                component.setDisabled(true)
              }
            })
            return newRow
          })

          if (isInteraction) {
            context.editReply({ components: disabledRows }).catch(() => {})
          } else {
            context.editReply({ components: disabledRows }).catch(() => {})
          }
        } catch (error) {
          console.log(`‚ö†Ô∏è [MUSIC] No se pudieron deshabilitar los botones de b√∫squeda`)
        }
      }, 60000) // 1 minuto

    } catch (error) {
      console.error(`‚ùå [MUSIC] Error en comando search:`, error)
      
      const embed = new EmbedBuilder()
        .setColor("#ff0000")
        .setTitle("‚ùå Error")
        .setDescription(`Ocurri√≥ un error durante la b√∫squeda: ${error.message}`)
        .setTimestamp()

      if (isInteraction && context.deferred) {
        await context.editReply({ embeds: [embed], ephemeral: true })
      } else {
        await reply({ embeds: [embed], ephemeral: isInteraction })
      }
    }
  },

  async slashExecute(interaction, client) {
    await this.execute(interaction)
  },

  // M√©todo para manejar la selecci√≥n de b√∫squeda
  async handleSearchSelection(interaction, videoIndex, videos, query) {
    try {
      console.log(`üéµ [MUSIC] Usuario seleccion√≥ video ${videoIndex + 1} de b√∫squeda`)

      const selectedVideo = videos[videoIndex]
      if (!selectedVideo) {
        console.log(`‚ùå [MUSIC] Video seleccionado no v√°lido`)
        await interaction.reply({
          content: "‚ùå Video seleccionado no v√°lido.",
          ephemeral: true
        })
        return
      }

      // Verificar si el usuario est√° en un canal de voz
      const voiceChannel = interaction.member.voice.channel
      if (!voiceChannel) {
        console.log(`‚ùå [MUSIC] Usuario no est√° en canal de voz`)
        await interaction.reply({
          content: "‚ùå Debes estar en un canal de voz para usar este comando.",
          ephemeral: true
        })
        return
      }

      // Verificar permisos del bot
      const permissions = voiceChannel.permissionsFor(interaction.client.user)
      if (!permissions.has(["Connect", "Speak"])) {
        console.log(`‚ùå [MUSIC] Bot sin permisos en canal ${voiceChannel.name}`)
        await interaction.reply({
          content: `‚ùå No tengo permisos para conectarme o hablar en **${voiceChannel.name}**`,
          ephemeral: true
        })
        return
      }

      await interaction.deferReply()

      const guildId = interaction.guild.id
      
      // Unirse al canal de voz si no est√° conectado
      let connection = musicManager.connections.get(guildId)
      if (!connection) {
        console.log(`üéµ [MUSIC] Bot no conectado, uni√©ndose al canal ${voiceChannel.name}`)
        const joinResult = await musicManager.joinVoiceChannel(voiceChannel, interaction.channel)
        
        if (!joinResult.success) {
          console.log(`‚ùå [MUSIC] Error al unirse al canal: ${joinResult.error}`)
          await interaction.editReply({
            content: `‚ùå Error al unirse al canal de voz: ${joinResult.error}`,
            ephemeral: true
          })
          return
        }
        connection = joinResult.connection
      }

      // Crear objeto de canci√≥n
      const song = {
        title: selectedVideo.title,
        url: selectedVideo.url,
        duration: musicManager.formatDuration(selectedVideo.duration.seconds),
        thumbnail: selectedVideo.thumbnail,
        channel: selectedVideo.author.name,
        durationSeconds: selectedVideo.duration.seconds
      }

      // Agregar a la cola
      const addResult = await musicManager.addToQueue(guildId, song, interaction.user)
      
      if (!addResult.success) {
        console.log(`‚ùå [MUSIC] Error al agregar a la cola: ${addResult.error}`)
        await interaction.editReply({
          content: `‚ùå Error al agregar la canci√≥n a la cola: ${addResult.error}`,
          ephemeral: true
        })
        return
      }

      console.log(`‚úÖ [MUSIC] Canci√≥n de b√∫squeda agregada exitosamente`)

      // Crear embed de confirmaci√≥n
      const embed = new EmbedBuilder()
        .setColor("#00ff00")
        .setTitle("‚úÖ Canci√≥n Agregada")
        .setDescription(`**${song.title}**`)
        .setThumbnail(song.thumbnail)
        .addFields(
          { name: "‚è±Ô∏è Duraci√≥n", value: song.duration, inline: true },
          { name: "üë§ Canal", value: song.channel, inline: true },
          { name: "üìä Posici√≥n", value: `#${addResult.position}`, inline: true },
          { name: "üîó URL", value: `[Ver en YouTube](${song.url})`, inline: false }
        )
        .setFooter({ text: `Solicitado por ${interaction.user.tag}` })
        .setTimestamp()

      // Si es la primera canci√≥n, mostrar mensaje especial
      if (addResult.position === 1) {
        embed.setTitle("üéµ Reproduciendo ahora")
        embed.setDescription(`**${song.title}**\n\n*Iniciando reproducci√≥n...*`)
      }

      await interaction.editReply({ embeds: [embed] })

      // Deshabilitar todos los botones
      const disabledComponents = interaction.message.components.map(row => {
        const newRow = ActionRowBuilder.from(row)
        newRow.components.forEach(component => {
          if (component instanceof ButtonBuilder) {
            component.setDisabled(true)
          }
        })
        return newRow
      })

      await interaction.message.edit({ components: disabledComponents })

    } catch (error) {
      console.error(`‚ùå [MUSIC] Error en handleSearchSelection:`, error)
      
      if (!interaction.replied && !interaction.deferred) {
        await interaction.reply({
          content: `‚ùå Error inesperado: ${error.message}`,
          ephemeral: true
        })
      } else {
        await interaction.editReply({
          content: `‚ùå Error inesperado: ${error.message}`,
          ephemeral: true
        })
      }
    }
  }
}

console.log("üéµ [MUSIC] Comando search cargado correctamente")